"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _SpinalNode = _interopRequireDefault(require("./SpinalNode"));

var _spinalCoreConnectorjs = _interopRequireDefault(require("spinal-core-connectorjs"));

var _SpinalRelationFactory = require("../Relations/SpinalRelationFactory");

var _Utilities = require("../Utilities");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Copyright 2018 SpinalCom - www.spinalcom.com
 *
 * This file is part of SpinalCore.
 *
 * Please read all of the following terms and conditions
 * of the Free Software license Agreement ("Agreement")
 * carefully.
 *
 * This Agreement is a legally binding contract between
 * the Licensee (as defined below) and SpinalCom that
 * sets forth the terms and conditions that govern your
 * use of the Program. By installing and/or using the
 * Program, you agree to abide by all the terms and
 * conditions stated or referenced herein.
 *
 * If you do not agree to abide by these terms and
 * conditions, do not demonstrate your acceptance and do
 * not install or use the Program.
 * You should have received a copy of the license along
 * with this file. If not, see
 * <http://resources.spinalcom.com/licenses.pdf>.
 */
class SpinalContext extends _SpinalNode.default {
  /**
   * Constructor for the SpinalContext class.
   * @param {String} name Name of the context
   * @param {String} type Type of the context, usually unused
   * @param {SpinalNode | Model} element Element of the context, usually unused
   */
  constructor(name, type = "SpinalContext", element) {
    super(name, type, element);
    this.info.id.set((0, _Utilities.guid)(this.constructor.name));
  }
  /**
   * Adds a child with a SpinalRelationLstPtrType.
   * @param {SpinalNode | Model} child Node to add as child
   * @param {String} relationName Name of the relation
   * @param {String} relationType This parameter is here only to properly override the parent method
   * @returns {Promise<SpinalNode>} The child node in a promise
   * @throws {TypeError} If the child is not a model
   * @throws {TypeError} If the relation name is not a string
   */


  addChild(child, relationName, relationType = _SpinalRelationFactory.SPINAL_RELATION_PTR_LST_TYPE) {
    return super.addChild(child, relationName, _SpinalRelationFactory.SPINAL_RELATION_PTR_LST_TYPE);
  }
  /**
   * Adds a child with a SpinalRelationLstPtrType and notices the context if a new relation was created.
   * @param {SpinalNode | Model} child Node to add as child
   * @param {String} relationName Name of the relation
   * @param {String} relationType This parameter is here only to properly override the parent method
   * @param {SpinalContext} context Context to update, usually unused
   * @returns {Promise<SpinalNode>} The child node in a promise
   */


  addChildInContext(child, relationName, relationType = _SpinalRelationFactory.SPINAL_RELATION_PTR_LST_TYPE, context = this) {
    return super.addChildInContext(child, relationName, _SpinalRelationFactory.SPINAL_RELATION_PTR_LST_TYPE, context);
  }
  /**
   * Return the children of the node that are registered in the context
   * @param {SpinalContext} context Context to use for the search, this by default
   * @returns {Promise<Array<SpinalNode>>} The children that were found
   */


  getChildrenInContext(context = this) {
    return super.getChildrenInContext(context);
  }

}

_spinalCoreConnectorjs.default.register_models([SpinalContext]);

var _default = SpinalContext;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9Ob2Rlcy9TcGluYWxDb250ZXh0LmpzIl0sIm5hbWVzIjpbIlNwaW5hbENvbnRleHQiLCJTcGluYWxOb2RlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwidHlwZSIsImVsZW1lbnQiLCJpbmZvIiwiaWQiLCJzZXQiLCJhZGRDaGlsZCIsImNoaWxkIiwicmVsYXRpb25OYW1lIiwicmVsYXRpb25UeXBlIiwiU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSIsImFkZENoaWxkSW5Db250ZXh0IiwiY29udGV4dCIsImdldENoaWxkcmVuSW5Db250ZXh0Iiwic3BpbmFsQ29yZSIsInJlZ2lzdGVyX21vZGVscyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQXVCQTs7QUFDQTs7QUFDQTs7QUFHQTs7OztBQTVCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0EsTUFBTUEsYUFBTixTQUE0QkMsbUJBQTVCLENBQXVDO0FBQ3JDOzs7Ozs7QUFNQUMsRUFBQUEsV0FBVyxDQUFDQyxJQUFELEVBQU9DLElBQUksR0FBRyxlQUFkLEVBQStCQyxPQUEvQixFQUF3QztBQUNqRCxVQUFNRixJQUFOLEVBQVlDLElBQVosRUFBa0JDLE9BQWxCO0FBRUEsU0FBS0MsSUFBTCxDQUFVQyxFQUFWLENBQWFDLEdBQWIsQ0FBaUIscUJBQUssS0FBS04sV0FBTCxDQUFpQkMsSUFBdEIsQ0FBakI7QUFDRDtBQUVEOzs7Ozs7Ozs7OztBQVNBTSxFQUFBQSxRQUFRLENBQUNDLEtBQUQsRUFBUUMsWUFBUixFQUFzQkMsWUFBWSxHQUFHQyxtREFBckMsRUFBbUU7QUFDekUsV0FBTyxNQUFNSixRQUFOLENBQWVDLEtBQWYsRUFBc0JDLFlBQXRCLEVBQW9DRSxtREFBcEMsQ0FBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7QUFRQUMsRUFBQUEsaUJBQWlCLENBQUNKLEtBQUQsRUFBUUMsWUFBUixFQUFzQkMsWUFBWSxHQUFHQyxtREFBckMsRUFBbUVFLE9BQU8sR0FBRyxJQUE3RSxFQUFtRjtBQUNsRyxXQUFPLE1BQU1ELGlCQUFOLENBQXdCSixLQUF4QixFQUErQkMsWUFBL0IsRUFBNkNFLG1EQUE3QyxFQUEyRUUsT0FBM0UsQ0FBUDtBQUNEO0FBRUQ7Ozs7Ozs7QUFLQUMsRUFBQUEsb0JBQW9CLENBQUNELE9BQU8sR0FBRyxJQUFYLEVBQWlCO0FBQ25DLFdBQU8sTUFBTUMsb0JBQU4sQ0FBMkJELE9BQTNCLENBQVA7QUFDRDs7QUE3Q29DOztBQWdEdkNFLCtCQUFXQyxlQUFYLENBQTJCLENBQUNsQixhQUFELENBQTNCOztlQUNlQSxhIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDE4IFNwaW5hbENvbSAtIHd3dy5zcGluYWxjb20uY29tXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgU3BpbmFsQ29yZS5cbiAqXG4gKiBQbGVhc2UgcmVhZCBhbGwgb2YgdGhlIGZvbGxvd2luZyB0ZXJtcyBhbmQgY29uZGl0aW9uc1xuICogb2YgdGhlIEZyZWUgU29mdHdhcmUgbGljZW5zZSBBZ3JlZW1lbnQgKFwiQWdyZWVtZW50XCIpXG4gKiBjYXJlZnVsbHkuXG4gKlxuICogVGhpcyBBZ3JlZW1lbnQgaXMgYSBsZWdhbGx5IGJpbmRpbmcgY29udHJhY3QgYmV0d2VlblxuICogdGhlIExpY2Vuc2VlIChhcyBkZWZpbmVkIGJlbG93KSBhbmQgU3BpbmFsQ29tIHRoYXRcbiAqIHNldHMgZm9ydGggdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIHRoYXQgZ292ZXJuIHlvdXJcbiAqIHVzZSBvZiB0aGUgUHJvZ3JhbS4gQnkgaW5zdGFsbGluZyBhbmQvb3IgdXNpbmcgdGhlXG4gKiBQcm9ncmFtLCB5b3UgYWdyZWUgdG8gYWJpZGUgYnkgYWxsIHRoZSB0ZXJtcyBhbmRcbiAqIGNvbmRpdGlvbnMgc3RhdGVkIG9yIHJlZmVyZW5jZWQgaGVyZWluLlxuICpcbiAqIElmIHlvdSBkbyBub3QgYWdyZWUgdG8gYWJpZGUgYnkgdGhlc2UgdGVybXMgYW5kXG4gKiBjb25kaXRpb25zLCBkbyBub3QgZGVtb25zdHJhdGUgeW91ciBhY2NlcHRhbmNlIGFuZCBkb1xuICogbm90IGluc3RhbGwgb3IgdXNlIHRoZSBQcm9ncmFtLlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgbGljZW5zZSBhbG9uZ1xuICogd2l0aCB0aGlzIGZpbGUuIElmIG5vdCwgc2VlXG4gKiA8aHR0cDovL3Jlc291cmNlcy5zcGluYWxjb20uY29tL2xpY2Vuc2VzLnBkZj4uXG4gKi9cbmltcG9ydCBTcGluYWxOb2RlIGZyb20gXCIuL1NwaW5hbE5vZGVcIjtcbmltcG9ydCBzcGluYWxDb3JlIGZyb20gXCJzcGluYWwtY29yZS1jb25uZWN0b3Jqc1wiO1xuaW1wb3J0IHtcbiAgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRVxufSBmcm9tIFwiLi4vUmVsYXRpb25zL1NwaW5hbFJlbGF0aW9uRmFjdG9yeVwiO1xuaW1wb3J0IHtcbiAgZ3VpZFxufSBmcm9tIFwiLi4vVXRpbGl0aWVzXCI7XG5cbmNsYXNzIFNwaW5hbENvbnRleHQgZXh0ZW5kcyBTcGluYWxOb2RlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZvciB0aGUgU3BpbmFsQ29udGV4dCBjbGFzcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY29udGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHRoZSBjb250ZXh0LCB1c3VhbGx5IHVudXNlZFxuICAgKiBAcGFyYW0ge1NwaW5hbE5vZGUgfCBNb2RlbH0gZWxlbWVudCBFbGVtZW50IG9mIHRoZSBjb250ZXh0LCB1c3VhbGx5IHVudXNlZFxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSwgdHlwZSA9IFwiU3BpbmFsQ29udGV4dFwiLCBlbGVtZW50KSB7XG4gICAgc3VwZXIobmFtZSwgdHlwZSwgZWxlbWVudCk7XG5cbiAgICB0aGlzLmluZm8uaWQuc2V0KGd1aWQodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoaWxkIHdpdGggYSBTcGluYWxSZWxhdGlvbkxzdFB0clR5cGUuXG4gICAqIEBwYXJhbSB7U3BpbmFsTm9kZSB8IE1vZGVsfSBjaGlsZCBOb2RlIHRvIGFkZCBhcyBjaGlsZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpb25OYW1lIE5hbWUgb2YgdGhlIHJlbGF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGlvblR5cGUgVGhpcyBwYXJhbWV0ZXIgaXMgaGVyZSBvbmx5IHRvIHByb3Blcmx5IG92ZXJyaWRlIHRoZSBwYXJlbnQgbWV0aG9kXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNwaW5hbE5vZGU+fSBUaGUgY2hpbGQgbm9kZSBpbiBhIHByb21pc2VcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgY2hpbGQgaXMgbm90IGEgbW9kZWxcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgcmVsYXRpb24gbmFtZSBpcyBub3QgYSBzdHJpbmdcbiAgICovXG4gIGFkZENoaWxkKGNoaWxkLCByZWxhdGlvbk5hbWUsIHJlbGF0aW9uVHlwZSA9IFNQSU5BTF9SRUxBVElPTl9QVFJfTFNUX1RZUEUpIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkQ2hpbGQoY2hpbGQsIHJlbGF0aW9uTmFtZSwgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoaWxkIHdpdGggYSBTcGluYWxSZWxhdGlvbkxzdFB0clR5cGUgYW5kIG5vdGljZXMgdGhlIGNvbnRleHQgaWYgYSBuZXcgcmVsYXRpb24gd2FzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7U3BpbmFsTm9kZSB8IE1vZGVsfSBjaGlsZCBOb2RlIHRvIGFkZCBhcyBjaGlsZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpb25OYW1lIE5hbWUgb2YgdGhlIHJlbGF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGlvblR5cGUgVGhpcyBwYXJhbWV0ZXIgaXMgaGVyZSBvbmx5IHRvIHByb3Blcmx5IG92ZXJyaWRlIHRoZSBwYXJlbnQgbWV0aG9kXG4gICAqIEBwYXJhbSB7U3BpbmFsQ29udGV4dH0gY29udGV4dCBDb250ZXh0IHRvIHVwZGF0ZSwgdXN1YWxseSB1bnVzZWRcbiAgICogQHJldHVybnMge1Byb21pc2U8U3BpbmFsTm9kZT59IFRoZSBjaGlsZCBub2RlIGluIGEgcHJvbWlzZVxuICAgKi9cbiAgYWRkQ2hpbGRJbkNvbnRleHQoY2hpbGQsIHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlID0gU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSwgY29udGV4dCA9IHRoaXMpIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkQ2hpbGRJbkNvbnRleHQoY2hpbGQsIHJlbGF0aW9uTmFtZSwgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSwgY29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZSB0aGF0IGFyZSByZWdpc3RlcmVkIGluIHRoZSBjb250ZXh0XG4gICAqIEBwYXJhbSB7U3BpbmFsQ29udGV4dH0gY29udGV4dCBDb250ZXh0IHRvIHVzZSBmb3IgdGhlIHNlYXJjaCwgdGhpcyBieSBkZWZhdWx0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PFNwaW5hbE5vZGU+Pn0gVGhlIGNoaWxkcmVuIHRoYXQgd2VyZSBmb3VuZFxuICAgKi9cbiAgZ2V0Q2hpbGRyZW5JbkNvbnRleHQoY29udGV4dCA9IHRoaXMpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0Q2hpbGRyZW5JbkNvbnRleHQoY29udGV4dCk7XG4gIH1cbn1cblxuc3BpbmFsQ29yZS5yZWdpc3Rlcl9tb2RlbHMoW1NwaW5hbENvbnRleHRdKTtcbmV4cG9ydCBkZWZhdWx0IFNwaW5hbENvbnRleHQ7XG4iXX0=